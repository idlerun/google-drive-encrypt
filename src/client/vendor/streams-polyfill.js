!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{var g;g="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,g["default"]=f()}}(function(){return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof require&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _require=require("./spec/reference-implementation/lib/readable-stream"),ReadableStream=_require.ReadableStream,_require2=require("./spec/reference-implementation/lib/writable-stream"),WritableStream=_require2.WritableStream,ByteLengthQueuingStrategy=require("./spec/reference-implementation/lib/byte-length-queuing-strategy"),CountQueuingStrategy=require("./spec/reference-implementation/lib/count-queuing-strategy"),TransformStream=require("./spec/reference-implementation/lib/transform-stream");exports.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,exports.CountQueuingStrategy=CountQueuingStrategy,exports.TransformStream=TransformStream,exports.ReadableStream=ReadableStream,exports.WritableStream=WritableStream;var interfaces={ReadableStream:ReadableStream,WritableStream:WritableStream,ByteLengthQueuingStrategy:ByteLengthQueuingStrategy,CountQueuingStrategy:CountQueuingStrategy,TransformStream:TransformStream};exports["default"]=interfaces,"undefined"!=typeof window&&Object.assign(window,interfaces)},{"./spec/reference-implementation/lib/byte-length-queuing-strategy":7,"./spec/reference-implementation/lib/count-queuing-strategy":8,"./spec/reference-implementation/lib/readable-stream":11,"./spec/reference-implementation/lib/transform-stream":12,"./spec/reference-implementation/lib/writable-stream":14}],2:[function(require,module,exports){function replacer(key,value){return util.isUndefined(value)?""+value:util.isNumber(value)&&!isFinite(value)?value.toString():util.isFunction(value)||util.isRegExp(value)?value.toString():value}function truncate(s,n){return util.isString(s)?s.length<n?s:s.slice(0,n):s}function getMessage(self){return truncate(JSON.stringify(self.actual,replacer),128)+" "+self.operator+" "+truncate(JSON.stringify(self.expected,replacer),128)}function fail(actual,expected,message,operator,stackStartFunction){throw new assert.AssertionError({message:message,actual:actual,expected:expected,operator:operator,stackStartFunction:stackStartFunction})}function ok(value,message){value||fail(value,!0,message,"==",assert.ok)}function _deepEqual(actual,expected){if(actual===expected)return!0;if(util.isBuffer(actual)&&util.isBuffer(expected)){if(actual.length!=expected.length)return!1;for(var i=0;i<actual.length;i++)if(actual[i]!==expected[i])return!1;return!0}return util.isDate(actual)&&util.isDate(expected)?actual.getTime()===expected.getTime():util.isRegExp(actual)&&util.isRegExp(expected)?actual.source===expected.source&&actual.global===expected.global&&actual.multiline===expected.multiline&&actual.lastIndex===expected.lastIndex&&actual.ignoreCase===expected.ignoreCase:util.isObject(actual)||util.isObject(expected)?objEquiv(actual,expected):actual==expected}function isArguments(object){return"[object Arguments]"==Object.prototype.toString.call(object)}function objEquiv(a,b){if(util.isNullOrUndefined(a)||util.isNullOrUndefined(b))return!1;if(a.prototype!==b.prototype)return!1;if(util.isPrimitive(a)||util.isPrimitive(b))return a===b;var aIsArgs=isArguments(a),bIsArgs=isArguments(b);if(aIsArgs&&!bIsArgs||!aIsArgs&&bIsArgs)return!1;if(aIsArgs)return a=pSlice.call(a),b=pSlice.call(b),_deepEqual(a,b);var key,i,ka=objectKeys(a),kb=objectKeys(b);if(ka.length!=kb.length)return!1;for(ka.sort(),kb.sort(),i=ka.length-1;i>=0;i--)if(ka[i]!=kb[i])return!1;for(i=ka.length-1;i>=0;i--)if(key=ka[i],!_deepEqual(a[key],b[key]))return!1;return!0}function expectedException(actual,expected){return actual&&expected?"[object RegExp]"==Object.prototype.toString.call(expected)?expected.test(actual):actual instanceof expected?!0:expected.call({},actual)===!0:!1}function _throws(shouldThrow,block,expected,message){var actual;util.isString(expected)&&(message=expected,expected=null);try{block()}catch(e){actual=e}if(message=(expected&&expected.name?" ("+expected.name+").":".")+(message?" "+message:"."),shouldThrow&&!actual&&fail(actual,expected,"Missing expected exception"+message),!shouldThrow&&expectedException(actual,expected)&&fail(actual,expected,"Got unwanted exception"+message),shouldThrow&&actual&&expected&&!expectedException(actual,expected)||!shouldThrow&&actual)throw actual}var util=require("util/"),pSlice=Array.prototype.slice,hasOwn=Object.prototype.hasOwnProperty,assert=module.exports=ok;assert.AssertionError=function(options){this.name="AssertionError",this.actual=options.actual,this.expected=options.expected,this.operator=options.operator,options.message?(this.message=options.message,this.generatedMessage=!1):(this.message=getMessage(this),this.generatedMessage=!0);var stackStartFunction=options.stackStartFunction||fail;if(Error.captureStackTrace)Error.captureStackTrace(this,stackStartFunction);else{var err=new Error;if(err.stack){var out=err.stack,fn_name=stackStartFunction.name,idx=out.indexOf("\n"+fn_name);if(idx>=0){var next_line=out.indexOf("\n",idx+1);out=out.substring(next_line+1)}this.stack=out}}},util.inherits(assert.AssertionError,Error),assert.fail=fail,assert.ok=ok,assert.equal=function(actual,expected,message){actual!=expected&&fail(actual,expected,message,"==",assert.equal)},assert.notEqual=function(actual,expected,message){actual==expected&&fail(actual,expected,message,"!=",assert.notEqual)},assert.deepEqual=function(actual,expected,message){_deepEqual(actual,expected)||fail(actual,expected,message,"deepEqual",assert.deepEqual)},assert.notDeepEqual=function(actual,expected,message){_deepEqual(actual,expected)&&fail(actual,expected,message,"notDeepEqual",assert.notDeepEqual)},assert.strictEqual=function(actual,expected,message){actual!==expected&&fail(actual,expected,message,"===",assert.strictEqual)},assert.notStrictEqual=function(actual,expected,message){actual===expected&&fail(actual,expected,message,"!==",assert.notStrictEqual)},assert["throws"]=function(block,error,message){_throws.apply(this,[!0].concat(pSlice.call(arguments)))},assert.doesNotThrow=function(block,message){_throws.apply(this,[!1].concat(pSlice.call(arguments)))},assert.ifError=function(err){if(err)throw err};var objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj)hasOwn.call(obj,key)&&keys.push(key);return keys}},{"util/":6}],3:[function(require,module,exports){"function"==typeof Object.create?module.exports=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})}:module.exports=function(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype,ctor.prototype=new TempCtor,ctor.prototype.constructor=ctor}},{}],4:[function(require,module,exports){function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var timeout=cachedSetTimeout(cleanUpNextTick);draining=!0;for(var len=queue.length;len;){for(currentQueue=queue,queue=[];++queueIndex<len;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,len=queue.length}currentQueue=null,draining=!1,cachedClearTimeout(timeout)}}function Item(fun,array){this.fun=fun,this.array=array}function noop(){}var cachedSetTimeout,cachedClearTimeout,process=module.exports={};!function(){try{cachedSetTimeout=setTimeout}catch(e){cachedSetTimeout=function(){throw new Error("setTimeout is not defined")}}try{cachedClearTimeout=clearTimeout}catch(e){cachedClearTimeout=function(){throw new Error("clearTimeout is not defined")}}}();var currentQueue,queue=[],draining=!1,queueIndex=-1;process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)args[i-1]=arguments[i];queue.push(new Item(fun,args)),1!==queue.length||draining||cachedSetTimeout(drainQueue,0)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.binding=function(name){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(dir){throw new Error("process.chdir is not supported")},process.umask=function(){return 0}},{}],5:[function(require,module,exports){module.exports=function(arg){return arg&&"object"==typeof arg&&"function"==typeof arg.copy&&"function"==typeof arg.fill&&"function"==typeof arg.readUInt8}},{}],6:[function(require,module,exports){(function(process,global){function inspect(obj,opts){var ctx={seen:[],stylize:stylizeNoColor};return arguments.length>=3&&(ctx.depth=arguments[2]),arguments.length>=4&&(ctx.colors=arguments[3]),isBoolean(opts)?ctx.showHidden=opts:opts&&exports._extend(ctx,opts),isUndefined(ctx.showHidden)&&(ctx.showHidden=!1),isUndefined(ctx.depth)&&(ctx.depth=2),isUndefined(ctx.colors)&&(ctx.colors=!1),isUndefined(ctx.customInspect)&&(ctx.customInspect=!0),ctx.colors&&(ctx.stylize=stylizeWithColor),formatValue(ctx,obj,ctx.depth)}function stylizeWithColor(str,styleType){var style=inspect.styles[styleType];return style?"["+inspect.colors[style][0]+"m"+str+"["+inspect.colors[style][1]+"m":str}function stylizeNoColor(str,styleType){return str}function arrayToHash(array){var hash={};return array.forEach(function(val,idx){hash[val]=!0}),hash}function formatValue(ctx,value,recurseTimes){if(ctx.customInspect&&value&&isFunction(value.inspect)&&value.inspect!==exports.inspect&&(!value.constructor||value.constructor.prototype!==value)){var ret=value.inspect(recurseTimes,ctx);return isString(ret)||(ret=formatValue(ctx,ret,recurseTimes)),ret}var primitive=formatPrimitive(ctx,value);if(primitive)return primitive;var keys=Object.keys(value),visibleKeys=arrayToHash(keys);if(ctx.showHidden&&(keys=Object.getOwnPropertyNames(value)),isError(value)&&(keys.indexOf("message")>=0||keys.indexOf("description")>=0))return formatError(value);if(0===keys.length){if(isFunction(value)){var name=value.name?": "+value.name:"";return ctx.stylize("[Function"+name+"]","special")}if(isRegExp(value))return ctx.stylize(RegExp.prototype.toString.call(value),"regexp");if(isDate(value))return ctx.stylize(Date.prototype.toString.call(value),"date");if(isError(value))return formatError(value)}var base="",array=!1,braces=["{","}"];if(isArray(value)&&(array=!0,braces=["[","]"]),isFunction(value)){var n=value.name?": "+value.name:"";base=" [Function"+n+"]"}if(isRegExp(value)&&(base=" "+RegExp.prototype.toString.call(value)),isDate(value)&&(base=" "+Date.prototype.toUTCString.call(value)),isError(value)&&(base=" "+formatError(value)),0===keys.length&&(!array||0==value.length))return braces[0]+base+braces[1];if(0>recurseTimes)return isRegExp(value)?ctx.stylize(RegExp.prototype.toString.call(value),"regexp"):ctx.stylize("[Object]","special");ctx.seen.push(value);var output;return output=array?formatArray(ctx,value,recurseTimes,visibleKeys,keys):keys.map(function(key){return formatProperty(ctx,value,recurseTimes,visibleKeys,key,array)}),ctx.seen.pop(),reduceToSingleString(output,base,braces)}function formatPrimitive(ctx,value){if(isUndefined(value))return ctx.stylize("undefined","undefined");if(isString(value)){var simple="'"+JSON.stringify(value).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return ctx.stylize(simple,"string")}return isNumber(value)?ctx.stylize(""+value,"number"):isBoolean(value)?ctx.stylize(""+value,"boolean"):isNull(value)?ctx.stylize("null","null"):void 0}function formatError(value){return"["+Error.prototype.toString.call(value)+"]"}function formatArray(ctx,value,recurseTimes,visibleKeys,keys){for(var output=[],i=0,l=value.length;l>i;++i)hasOwnProperty(value,String(i))?output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,String(i),!0)):output.push("");return keys.forEach(function(key){key.match(/^\d+$/)||output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,key,!0))}),output}function formatProperty(ctx,value,recurseTimes,visibleKeys,key,array){var name,str,desc;if(desc=Object.getOwnPropertyDescriptor(value,key)||{value:value[key]},desc.get?str=desc.set?ctx.stylize("[Getter/Setter]","special"):ctx.stylize("[Getter]","special"):desc.set&&(str=ctx.stylize("[Setter]","special")),hasOwnProperty(visibleKeys,key)||(name="["+key+"]"),str||(ctx.seen.indexOf(desc.value)<0?(str=isNull(recurseTimes)?formatValue(ctx,desc.value,null):formatValue(ctx,desc.value,recurseTimes-1),str.indexOf("\n")>-1&&(str=array?str.split("\n").map(function(line){return"  "+line}).join("\n").substr(2):"\n"+str.split("\n").map(function(line){return"   "+line}).join("\n"))):str=ctx.stylize("[Circular]","special")),isUndefined(name)){if(array&&key.match(/^\d+$/))return str;name=JSON.stringify(""+key),name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(name=name.substr(1,name.length-2),name=ctx.stylize(name,"name")):(name=name.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),name=ctx.stylize(name,"string"))}return name+": "+str}function reduceToSingleString(output,base,braces){var numLinesEst=0,length=output.reduce(function(prev,cur){return numLinesEst++,cur.indexOf("\n")>=0&&numLinesEst++,prev+cur.replace(/\u001b\[\d\d?m/g,"").length+1},0);return length>60?braces[0]+(""===base?"":base+"\n ")+" "+output.join(",\n  ")+" "+braces[1]:braces[0]+base+" "+output.join(", ")+" "+braces[1]}function isArray(ar){return Array.isArray(ar)}function isBoolean(arg){return"boolean"==typeof arg}function isNull(arg){return null===arg}function isNullOrUndefined(arg){return null==arg}function isNumber(arg){return"number"==typeof arg}function isString(arg){return"string"==typeof arg}function isSymbol(arg){return"symbol"==typeof arg}function isUndefined(arg){return void 0===arg}function isRegExp(re){return isObject(re)&&"[object RegExp]"===objectToString(re)}function isObject(arg){return"object"==typeof arg&&null!==arg}function isDate(d){return isObject(d)&&"[object Date]"===objectToString(d)}function isError(e){return isObject(e)&&("[object Error]"===objectToString(e)||e instanceof Error)}function isFunction(arg){return"function"==typeof arg}function isPrimitive(arg){return null===arg||"boolean"==typeof arg||"number"==typeof arg||"string"==typeof arg||"symbol"==typeof arg||"undefined"==typeof arg}function objectToString(o){return Object.prototype.toString.call(o)}function pad(n){return 10>n?"0"+n.toString(10):n.toString(10)}function timestamp(){var d=new Date,time=[pad(d.getHours()),pad(d.getMinutes()),pad(d.getSeconds())].join(":");return[d.getDate(),months[d.getMonth()],time].join(" ")}function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)}var formatRegExp=/%[sdj%]/g;exports.format=function(f){if(!isString(f)){for(var objects=[],i=0;i<arguments.length;i++)objects.push(inspect(arguments[i]));return objects.join(" ")}for(var i=1,args=arguments,len=args.length,str=String(f).replace(formatRegExp,function(x){if("%%"===x)return"%";if(i>=len)return x;switch(x){case"%s":return String(args[i++]);case"%d":return Number(args[i++]);case"%j":try{return JSON.stringify(args[i++])}catch(_){return"[Circular]"}default:return x}}),x=args[i];len>i;x=args[++i])str+=isNull(x)||!isObject(x)?" "+x:" "+inspect(x);return str},exports.deprecate=function(fn,msg){function deprecated(){if(!warned){if(process.throwDeprecation)throw new Error(msg);process.traceDeprecation?console.trace(msg):console.error(msg),warned=!0}return fn.apply(this,arguments)}if(isUndefined(global.process))return function(){return exports.deprecate(fn,msg).apply(this,arguments)};if(process.noDeprecation===!0)return fn;var warned=!1;return deprecated};var debugEnviron,debugs={};exports.debuglog=function(set){if(isUndefined(debugEnviron)&&(debugEnviron=process.env.NODE_DEBUG||""),set=set.toUpperCase(),!debugs[set])if(new RegExp("\\b"+set+"\\b","i").test(debugEnviron)){var pid=process.pid;debugs[set]=function(){var msg=exports.format.apply(exports,arguments);console.error("%s %d: %s",set,pid,msg)}}else debugs[set]=function(){};return debugs[set]},exports.inspect=inspect,inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},inspect.styles={special:"cyan",number:"yellow","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"},exports.isArray=isArray,exports.isBoolean=isBoolean,exports.isNull=isNull,exports.isNullOrUndefined=isNullOrUndefined,exports.isNumber=isNumber,exports.isString=isString,exports.isSymbol=isSymbol,exports.isUndefined=isUndefined,exports.isRegExp=isRegExp,exports.isObject=isObject,exports.isDate=isDate,exports.isError=isError,exports.isFunction=isFunction,exports.isPrimitive=isPrimitive,exports.isBuffer=require("./support/isBuffer");var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];exports.log=function(){console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))},exports.inherits=require("inherits"),exports._extend=function(origin,add){if(!add||!isObject(add))return origin;for(var keys=Object.keys(add),i=keys.length;i--;)origin[keys[i]]=add[keys[i]];return origin}}).call(this,require("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./support/isBuffer":5,_process:4,inherits:3}],7:[function(require,module,exports){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_require=require("./helpers.js"),createDataProperty=_require.createDataProperty;module.exports=function(){function ByteLengthQueuingStrategy(_ref){var highWaterMark=_ref.highWaterMark;_classCallCheck(this,ByteLengthQueuingStrategy),createDataProperty(this,"highWaterMark",highWaterMark)}return _createClass(ByteLengthQueuingStrategy,[{key:"size",value:function(chunk){return chunk.byteLength}}]),ByteLengthQueuingStrategy}()},{"./helpers.js":9}],8:[function(require,module,exports){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_require=require("./helpers.js"),createDataProperty=_require.createDataProperty;module.exports=function(){function CountQueuingStrategy(_ref){var highWaterMark=_ref.highWaterMark;_classCallCheck(this,CountQueuingStrategy),createDataProperty(this,"highWaterMark",highWaterMark)}return _createClass(CountQueuingStrategy,[{key:"size",value:function(){return 1}}]),CountQueuingStrategy}()},{"./helpers.js":9}],9:[function(require,module,exports){"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol?"symbol":typeof obj},assert=require("assert");exports.promiseCall=function(func){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_len>_key;_key++)args[_key-1]=arguments[_key];try{return Promise.resolve(func.apply(void 0,args))}catch(e){return Promise.reject(e)}},exports.typeIsObject=function(x){return"object"===("undefined"==typeof x?"undefined":_typeof(x))&&null!==x||"function"==typeof x},exports.toInteger=function(v){return v=Number(v),isNaN(v)?0:0>v?-1*Math.floor(Math.abs(v)):Math.floor(Math.abs(v))},exports.createDataProperty=function(o,p,v){assert(exports.typeIsObject(o)),Object.defineProperty(o,p,{value:v,writable:!0,enumerable:!0,configurable:!0})},exports.createArrayFromList=function(elements){return elements.slice()},exports.ArrayBufferCopy=function(dest,destOffset,src,srcOffset,n){new Uint8Array(dest).set(new Uint8Array(src,srcOffset,n),destOffset)},exports.CreateIterResultObject=function(value,done){assert("boolean"==typeof done);var obj={};return Object.defineProperty(obj,"value",{value:value,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(obj,"done",{value:done,enumerable:!0,writable:!0,configurable:!0}),obj},exports.IsFiniteNonNegativeNumber=function(v){return Number.isNaN(v)?!1:v===1/0?!1:!(0>v)},exports.InvokeOrNoop=function(O,P,args){var method=O[P];if(void 0!==method)return method.apply(O,args)},exports.PromiseInvokeOrNoop=function(O,P,args){var method=void 0;try{method=O[P]}catch(methodE){return Promise.reject(methodE)}if(void 0===method)return Promise.resolve(void 0);try{return Promise.resolve(method.apply(O,args))}catch(e){return Promise.reject(e)}},exports.PromiseInvokeOrFallbackOrNoop=function(O,P1,args1,P2,args2){var method=void 0;try{method=O[P1]}catch(methodE){return Promise.reject(methodE)}if(void 0===method)return exports.PromiseInvokeOrNoop(O,P2,args2);try{return Promise.resolve(method.apply(O,args1))}catch(e){return Promise.reject(e)}},exports.SameRealmTransfer=function(O){return O},exports.ValidateAndNormalizeHighWaterMark=function(highWaterMark){if(highWaterMark=Number(highWaterMark),Number.isNaN(highWaterMark)||0>highWaterMark)throw new RangeError("highWaterMark property of a queuing strategy must be nonnegative and non-NaN");return highWaterMark},exports.ValidateAndNormalizeQueuingStrategy=function(size,highWaterMark){if(void 0!==size&&"function"!=typeof size)throw new TypeError("size property of a queuing strategy must be a function");return highWaterMark=exports.ValidateAndNormalizeHighWaterMark(highWaterMark),{size:size,highWaterMark:highWaterMark}}},{assert:2}],10:[function(require,module,exports){"use strict";var assert=require("assert"),_require=require("./helpers.js"),IsFiniteNonNegativeNumber=_require.IsFiniteNonNegativeNumber;exports.DequeueValue=function(queue){assert(queue.length>0,"Spec-level failure: should never dequeue from an empty queue.");var pair=queue.shift();return queue._totalSize-=pair.size,pair.value},exports.EnqueueValueWithSize=function(queue,value,size){if(size=Number(size),!IsFiniteNonNegativeNumber(size))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");queue.push({value:value,size:size}),void 0===queue._totalSize&&(queue._totalSize=0),queue._totalSize+=size},exports.GetTotalQueueSize=function(queue){return void 0===queue._totalSize&&(queue._totalSize=0),queue._totalSize},exports.PeekQueueValue=function(queue){assert(queue.length>0,"Spec-level failure: should never peek at an empty queue.");var pair=queue[0];return pair.value}},{"./helpers.js":9,assert:2}],11:[function(require,module,exports){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function AcquireReadableStreamBYOBReader(stream){return new ReadableStreamBYOBReader(stream)}function AcquireReadableStreamDefaultReader(stream){return new ReadableStreamDefaultReader(stream)}function IsReadableStream(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_readableStreamController"):!1}function IsReadableStreamDisturbed(stream){return assert(IsReadableStream(stream)===!0,"IsReadableStreamDisturbed should only be used on known readable streams"),stream._disturbed}function IsReadableStreamLocked(stream){return assert(IsReadableStream(stream)===!0,"IsReadableStreamLocked should only be used on known readable streams"),void 0!==stream._reader}function ReadableStreamTee(stream,shouldClone){assert(IsReadableStream(stream)===!0),assert("boolean"==typeof shouldClone);var reader=AcquireReadableStreamDefaultReader(stream),teeState={closedOrErrored:!1,canceled1:!1,canceled2:!1,reason1:void 0,reason2:void 0};teeState.promise=new Promise(function(resolve){teeState._resolve=resolve});var pull=create_ReadableStreamTeePullFunction();pull._reader=reader,pull._teeState=teeState,pull._shouldClone=shouldClone;var cancel1=create_ReadableStreamTeeBranch1CancelFunction();cancel1._stream=stream,cancel1._teeState=teeState;var cancel2=create_ReadableStreamTeeBranch2CancelFunction();cancel2._stream=stream,cancel2._teeState=teeState;var underlyingSource1=Object.create(Object.prototype);createDataProperty(underlyingSource1,"pull",pull),createDataProperty(underlyingSource1,"cancel",cancel1);var branch1Stream=new ReadableStream(underlyingSource1),underlyingSource2=Object.create(Object.prototype);createDataProperty(underlyingSource2,"pull",pull),createDataProperty(underlyingSource2,"cancel",cancel2);var branch2Stream=new ReadableStream(underlyingSource2);return pull._branch1=branch1Stream._readableStreamController,pull._branch2=branch2Stream._readableStreamController,reader._closedPromise["catch"](function(r){teeState.closedOrErrored!==!0&&(ReadableStreamDefaultControllerError(pull._branch1,r),ReadableStreamDefaultControllerError(pull._branch2,r),teeState.closedOrErrored=!0)}),[branch1Stream,branch2Stream]}function create_ReadableStreamTeePullFunction(){function f(){var reader=f._reader,branch1=f._branch1,branch2=f._branch2,teeState=f._teeState;return ReadableStreamDefaultReaderRead(reader).then(function(result){assert(typeIsObject(result));var value=result.value,done=result.done;if(assert("boolean"==typeof done),done===!0&&teeState.closedOrErrored===!1&&(teeState.canceled1===!1&&ReadableStreamDefaultControllerClose(branch1),teeState.canceled2===!1&&ReadableStreamDefaultControllerClose(branch2),teeState.closedOrErrored=!0),teeState.closedOrErrored!==!0){if(teeState.canceled1===!1){var value1=value;ReadableStreamDefaultControllerEnqueue(branch1,value1)}if(teeState.canceled2===!1){var value2=value;ReadableStreamDefaultControllerEnqueue(branch2,value2)}}})}return f}function create_ReadableStreamTeeBranch1CancelFunction(){function f(reason){var stream=f._stream,teeState=f._teeState;if(teeState.canceled1=!0,teeState.reason1=reason,teeState.canceled2===!0){var compositeReason=createArrayFromList([teeState.reason1,teeState.reason2]),cancelResult=ReadableStreamCancel(stream,compositeReason);teeState._resolve(cancelResult)}return teeState.promise}return f}function create_ReadableStreamTeeBranch2CancelFunction(){function f(reason){var stream=f._stream,teeState=f._teeState;if(teeState.canceled2=!0,teeState.reason2=reason,teeState.canceled1===!0){var compositeReason=createArrayFromList([teeState.reason1,teeState.reason2]),cancelResult=ReadableStreamCancel(stream,compositeReason);teeState._resolve(cancelResult)}return teeState.promise}return f}function ReadableStreamAddReadIntoRequest(stream){assert(IsReadableStreamBYOBReader(stream._reader)===!0),assert("readable"===stream._state||"closed"===stream._state);var promise=new Promise(function(resolve,reject){var readIntoRequest={_resolve:resolve,_reject:reject};stream._reader._readIntoRequests.push(readIntoRequest)});return promise}function ReadableStreamAddReadRequest(stream){assert(IsReadableStreamDefaultReader(stream._reader)===!0),assert("readable"===stream._state);var promise=new Promise(function(resolve,reject){var readRequest={_resolve:resolve,_reject:reject};stream._reader._readRequests.push(readRequest)});return promise}function ReadableStreamCancel(stream,reason){if(stream._disturbed=!0,"closed"===stream._state)return Promise.resolve(void 0);if("errored"===stream._state)return Promise.reject(stream._storedError);ReadableStreamClose(stream);var sourceCancelPromise=stream._readableStreamController[InternalCancel](reason);return sourceCancelPromise.then(function(){})}function ReadableStreamClose(stream){assert("readable"===stream._state),stream._state="closed";var reader=stream._reader;if(void 0!==reader){if(IsReadableStreamDefaultReader(reader)===!0){var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _step,_iterator=reader._readRequests[Symbol.iterator]();!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var _resolve=_step.value._resolve;_resolve(CreateIterResultObject(void 0,!0))}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator["return"]&&_iterator["return"]()}finally{if(_didIteratorError)throw _iteratorError}}reader._readRequests=[]}defaultReaderClosedPromiseResolve(reader)}}function ReadableStreamError(stream,e){assert(IsReadableStream(stream)===!0,"stream must be ReadableStream"),assert("readable"===stream._state,"state must be readable"),stream._state="errored",stream._storedError=e;var reader=stream._reader;if(void 0!==reader){if(IsReadableStreamDefaultReader(reader)===!0){var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _step2,_iterator2=reader._readRequests[Symbol.iterator]();!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){var readRequest=_step2.value;readRequest._reject(e)}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{!_iteratorNormalCompletion2&&_iterator2["return"]&&_iterator2["return"]()}finally{if(_didIteratorError2)throw _iteratorError2}}reader._readRequests=[]}else{assert(IsReadableStreamBYOBReader(reader),"reader must be ReadableStreamBYOBReader");var _iteratorNormalCompletion3=!0,_didIteratorError3=!1,_iteratorError3=void 0;try{for(var _step3,_iterator3=reader._readIntoRequests[Symbol.iterator]();!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=!0){var readIntoRequest=_step3.value;readIntoRequest._reject(e)}}catch(err){_didIteratorError3=!0,_iteratorError3=err}finally{try{!_iteratorNormalCompletion3&&_iterator3["return"]&&_iterator3["return"]()}finally{if(_didIteratorError3)throw _iteratorError3}}reader._readIntoRequests=[]}defaultReaderClosedPromiseReject(reader,e)}}function ReadableStreamFulfillReadIntoRequest(stream,chunk,done){var reader=stream._reader;assert(reader._readIntoRequests.length>0);var readIntoRequest=reader._readIntoRequests.shift();readIntoRequest._resolve(CreateIterResultObject(chunk,done))}function ReadableStreamFulfillReadRequest(stream,chunk,done){var reader=stream._reader;assert(reader._readRequests.length>0);var readRequest=reader._readRequests.shift();readRequest._resolve(CreateIterResultObject(chunk,done))}function ReadableStreamGetNumReadIntoRequests(stream){return stream._reader._readIntoRequests.length}function ReadableStreamGetNumReadRequests(stream){
return stream._reader._readRequests.length}function ReadableStreamHasBYOBReader(stream){var reader=stream._reader;return void 0===reader?!1:IsReadableStreamBYOBReader(reader)!==!1}function ReadableStreamHasDefaultReader(stream){var reader=stream._reader;return void 0===reader?!1:IsReadableStreamDefaultReader(reader)!==!1}function IsReadableStreamBYOBReader(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_readIntoRequests"):!1}function IsReadableStreamDefaultReader(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_readRequests"):!1}function ReadableStreamReaderGenericInitialize(reader,stream){reader._ownerReadableStream=stream,stream._reader=reader,"readable"===stream._state?defaultReaderClosedPromiseInitialize(reader):"closed"===stream._state?defaultReaderClosedPromiseInitializeAsResolved(reader):(assert("errored"===stream._state,"state must be errored"),defaultReaderClosedPromiseInitializeAsRejected(reader,stream._storedError))}function ReadableStreamReaderGenericCancel(reader,reason){var stream=reader._ownerReadableStream;return assert(void 0!==stream),ReadableStreamCancel(stream,reason)}function ReadableStreamReaderGenericRelease(reader){assert(void 0!==reader._ownerReadableStream),assert(reader._ownerReadableStream._reader===reader),"readable"===reader._ownerReadableStream._state?defaultReaderClosedPromiseReject(reader,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):defaultReaderClosedPromiseResetToRejected(reader,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),reader._ownerReadableStream._reader=void 0,reader._ownerReadableStream=void 0}function ReadableStreamBYOBReaderRead(reader,view){var stream=reader._ownerReadableStream;return assert(void 0!==stream),stream._disturbed=!0,"errored"===stream._state?Promise.reject(stream._storedError):ReadableByteStreamControllerPullInto(stream._readableStreamController,view)}function ReadableStreamDefaultReaderRead(reader){var stream=reader._ownerReadableStream;return assert(void 0!==stream),stream._disturbed=!0,"closed"===stream._state?Promise.resolve(CreateIterResultObject(void 0,!0)):"errored"===stream._state?Promise.reject(stream._storedError):(assert("readable"===stream._state),stream._readableStreamController[InternalPull]())}function IsReadableStreamDefaultController(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_underlyingSource"):!1}function ReadableStreamDefaultControllerCallPullIfNeeded(controller){var shouldPull=ReadableStreamDefaultControllerShouldCallPull(controller);if(shouldPull!==!1){if(controller._pulling===!0)return void(controller._pullAgain=!0);controller._pulling=!0;var pullPromise=PromiseInvokeOrNoop(controller._underlyingSource,"pull",[controller]);pullPromise.then(function(){return controller._pulling=!1,controller._pullAgain===!0?(controller._pullAgain=!1,ReadableStreamDefaultControllerCallPullIfNeeded(controller)):void 0},function(e){ReadableStreamDefaultControllerErrorIfNeeded(controller,e)})["catch"](rethrowAssertionErrorRejection)}}function ReadableStreamDefaultControllerShouldCallPull(controller){var stream=controller._controlledReadableStream;if("closed"===stream._state||"errored"===stream._state)return!1;if(controller._closeRequested===!0)return!1;if(controller._started===!1)return!1;if(IsReadableStreamLocked(stream)===!0&&ReadableStreamGetNumReadRequests(stream)>0)return!0;var desiredSize=ReadableStreamDefaultControllerGetDesiredSize(controller);return desiredSize>0}function ReadableStreamDefaultControllerClose(controller){var stream=controller._controlledReadableStream;assert(controller._closeRequested===!1),assert("readable"===stream._state),controller._closeRequested=!0,0===controller._queue.length&&ReadableStreamClose(stream)}function ReadableStreamDefaultControllerEnqueue(controller,chunk){var stream=controller._controlledReadableStream;if(assert(controller._closeRequested===!1),assert("readable"===stream._state),IsReadableStreamLocked(stream)===!0&&ReadableStreamGetNumReadRequests(stream)>0)ReadableStreamFulfillReadRequest(stream,chunk,!1);else{var chunkSize=1;if(void 0!==controller._strategySize)try{chunkSize=controller._strategySize(chunk)}catch(chunkSizeE){throw ReadableStreamDefaultControllerErrorIfNeeded(controller,chunkSizeE),chunkSizeE}try{EnqueueValueWithSize(controller._queue,chunk,chunkSize)}catch(enqueueE){throw ReadableStreamDefaultControllerErrorIfNeeded(controller,enqueueE),enqueueE}}ReadableStreamDefaultControllerCallPullIfNeeded(controller)}function ReadableStreamDefaultControllerError(controller,e){var stream=controller._controlledReadableStream;assert("readable"===stream._state),controller._queue=[],ReadableStreamError(stream,e)}function ReadableStreamDefaultControllerErrorIfNeeded(controller,e){"readable"===controller._controlledReadableStream._state&&ReadableStreamDefaultControllerError(controller,e)}function ReadableStreamDefaultControllerGetDesiredSize(controller){var queueSize=GetTotalQueueSize(controller._queue);return controller._strategyHWM-queueSize}function IsReadableByteStreamController(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_underlyingByteSource"):!1}function IsReadableStreamBYOBRequest(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_associatedReadableByteStreamController"):!1}function ReadableByteStreamControllerCallPullIfNeeded(controller){var shouldPull=ReadableByteStreamControllerShouldCallPull(controller);if(shouldPull!==!1){if(controller._pulling===!0)return void(controller._pullAgain=!0);controller._pullAgain=!1,controller._pulling=!0;var pullPromise=PromiseInvokeOrNoop(controller._underlyingByteSource,"pull",[controller]);pullPromise.then(function(){controller._pulling=!1,controller._pullAgain===!0&&(controller._pullAgain=!1,ReadableByteStreamControllerCallPullIfNeeded(controller))},function(e){"readable"===controller._controlledReadableStream._state&&ReadableByteStreamControllerError(controller,e)})["catch"](rethrowAssertionErrorRejection)}}function ReadableByteStreamControllerClearPendingPullIntos(controller){ReadableByteStreamControllerInvalidateBYOBRequest(controller),controller._pendingPullIntos=[]}function ReadableByteStreamControllerCommitPullIntoDescriptor(stream,pullIntoDescriptor){assert("errored"!==stream._state,"state must not be errored");var done=!1;"closed"===stream._state&&(assert(0===pullIntoDescriptor.bytesFilled),done=!0);var filledView=ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);"default"===pullIntoDescriptor.readerType?ReadableStreamFulfillReadRequest(stream,filledView,done):(assert("byob"===pullIntoDescriptor.readerType),ReadableStreamFulfillReadIntoRequest(stream,filledView,done))}function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor){var bytesFilled=pullIntoDescriptor.bytesFilled,elementSize=pullIntoDescriptor.elementSize;return assert(bytesFilled<=pullIntoDescriptor.byteLength),assert(bytesFilled%elementSize===0),new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer,pullIntoDescriptor.byteOffset,bytesFilled/elementSize)}function ReadableByteStreamControllerEnqueueChunkToQueue(controller,buffer,byteOffset,byteLength){controller._queue.push({buffer:buffer,byteOffset:byteOffset,byteLength:byteLength}),controller._totalQueuedBytes+=byteLength}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor){var elementSize=pullIntoDescriptor.elementSize,currentAlignedBytes=pullIntoDescriptor.bytesFilled-pullIntoDescriptor.bytesFilled%elementSize,maxBytesToCopy=Math.min(controller._totalQueuedBytes,pullIntoDescriptor.byteLength-pullIntoDescriptor.bytesFilled),maxBytesFilled=pullIntoDescriptor.bytesFilled+maxBytesToCopy,maxAlignedBytes=maxBytesFilled-maxBytesFilled%elementSize,totalBytesToCopyRemaining=maxBytesToCopy,ready=!1;maxAlignedBytes>currentAlignedBytes&&(totalBytesToCopyRemaining=maxAlignedBytes-pullIntoDescriptor.bytesFilled,ready=!0);for(var queue=controller._queue;totalBytesToCopyRemaining>0;){var headOfQueue=queue[0],bytesToCopy=Math.min(totalBytesToCopyRemaining,headOfQueue.byteLength),destStart=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled;ArrayBufferCopy(pullIntoDescriptor.buffer,destStart,headOfQueue.buffer,headOfQueue.byteOffset,bytesToCopy),headOfQueue.byteLength===bytesToCopy?queue.shift():(headOfQueue.byteOffset+=bytesToCopy,headOfQueue.byteLength-=bytesToCopy),controller._totalQueuedBytes-=bytesToCopy,ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller,bytesToCopy,pullIntoDescriptor),totalBytesToCopyRemaining-=bytesToCopy}return ready===!1&&(assert(0===controller._totalQueuedBytes,"queue must be empty"),assert(pullIntoDescriptor.bytesFilled>0),assert(pullIntoDescriptor.bytesFilled<pullIntoDescriptor.elementSize)),ready}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller,size,pullIntoDescriptor){assert(0===controller._pendingPullIntos.length||controller._pendingPullIntos[0]===pullIntoDescriptor),ReadableByteStreamControllerInvalidateBYOBRequest(controller),pullIntoDescriptor.bytesFilled+=size}function ReadableByteStreamControllerHandleQueueDrain(controller){assert("readable"===controller._controlledReadableStream._state),0===controller._totalQueuedBytes&&controller._closeRequested===!0?ReadableStreamClose(controller._controlledReadableStream):ReadableByteStreamControllerCallPullIfNeeded(controller)}function ReadableByteStreamControllerInvalidateBYOBRequest(controller){void 0!==controller._byobRequest&&(controller._byobRequest._associatedReadableByteStreamController=void 0,controller._byobRequest._view=void 0,controller._byobRequest=void 0)}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller){for(assert(controller._closeRequested===!1);controller._pendingPullIntos.length>0;){if(0===controller._totalQueuedBytes)return;var pullIntoDescriptor=controller._pendingPullIntos[0];ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor)===!0&&(ReadableByteStreamControllerShiftPendingPullInto(controller),ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream,pullIntoDescriptor))}}function ReadableByteStreamControllerPullInto(controller,view){var stream=controller._controlledReadableStream,elementSize=1;view.constructor!==DataView&&(elementSize=view.constructor.BYTES_PER_ELEMENT);var ctor=view.constructor,pullIntoDescriptor={buffer:view.buffer,byteOffset:view.byteOffset,byteLength:view.byteLength,bytesFilled:0,elementSize:elementSize,ctor:ctor,readerType:"byob"};if(controller._pendingPullIntos.length>0)return pullIntoDescriptor.buffer=SameRealmTransfer(pullIntoDescriptor.buffer),controller._pendingPullIntos.push(pullIntoDescriptor),ReadableStreamAddReadIntoRequest(stream);if("closed"===stream._state){var emptyView=new view.constructor(view.buffer,view.byteOffset,0);return Promise.resolve(CreateIterResultObject(emptyView,!0))}if(controller._totalQueuedBytes>0){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor)===!0){var filledView=ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);return ReadableByteStreamControllerHandleQueueDrain(controller),Promise.resolve(CreateIterResultObject(filledView,!1))}if(controller._closeRequested===!0){var e=new TypeError("Insufficient bytes to fill elements in the given buffer");return ReadableByteStreamControllerError(controller,e),Promise.reject(e)}}pullIntoDescriptor.buffer=SameRealmTransfer(pullIntoDescriptor.buffer),controller._pendingPullIntos.push(pullIntoDescriptor);var promise=ReadableStreamAddReadIntoRequest(stream);return ReadableByteStreamControllerCallPullIfNeeded(controller),promise}function ReadableByteStreamControllerRespondInClosedState(controller,firstDescriptor){firstDescriptor.buffer=SameRealmTransfer(firstDescriptor.buffer),assert(0===firstDescriptor.bytesFilled,"bytesFilled must be 0");for(var stream=controller._controlledReadableStream;ReadableStreamGetNumReadIntoRequests(stream)>0;){var pullIntoDescriptor=ReadableByteStreamControllerShiftPendingPullInto(controller);ReadableByteStreamControllerCommitPullIntoDescriptor(stream,pullIntoDescriptor)}}function ReadableByteStreamControllerRespondInReadableState(controller,bytesWritten,pullIntoDescriptor){if(pullIntoDescriptor.bytesFilled+bytesWritten>pullIntoDescriptor.byteLength)throw new RangeError("bytesWritten out of range");if(ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller,bytesWritten,pullIntoDescriptor),!(pullIntoDescriptor.bytesFilled<pullIntoDescriptor.elementSize)){ReadableByteStreamControllerShiftPendingPullInto(controller);var remainderSize=pullIntoDescriptor.bytesFilled%pullIntoDescriptor.elementSize;if(remainderSize>0){var end=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled,remainder=pullIntoDescriptor.buffer.slice(end-remainderSize,end);ReadableByteStreamControllerEnqueueChunkToQueue(controller,remainder,0,remainder.byteLength)}pullIntoDescriptor.buffer=SameRealmTransfer(pullIntoDescriptor.buffer),pullIntoDescriptor.bytesFilled-=remainderSize,ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream,pullIntoDescriptor),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)}}function ReadableByteStreamControllerRespondInternal(controller,bytesWritten){var firstDescriptor=controller._pendingPullIntos[0],stream=controller._controlledReadableStream;if("closed"===stream._state){if(0!==bytesWritten)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");ReadableByteStreamControllerRespondInClosedState(controller,firstDescriptor)}else assert("readable"===stream._state),ReadableByteStreamControllerRespondInReadableState(controller,bytesWritten,firstDescriptor)}function ReadableByteStreamControllerShiftPendingPullInto(controller){var descriptor=controller._pendingPullIntos.shift();return ReadableByteStreamControllerInvalidateBYOBRequest(controller),descriptor}function ReadableByteStreamControllerShouldCallPull(controller){var stream=controller._controlledReadableStream;return"readable"!==stream._state?!1:controller._closeRequested===!0?!1:controller._started===!1?!1:ReadableStreamHasDefaultReader(stream)&&ReadableStreamGetNumReadRequests(stream)>0?!0:ReadableStreamHasBYOBReader(stream)&&ReadableStreamGetNumReadIntoRequests(stream)>0?!0:ReadableByteStreamControllerGetDesiredSize(controller)>0}function ReadableByteStreamControllerClose(controller){var stream=controller._controlledReadableStream;if(assert(controller._closeRequested===!1),assert("readable"===stream._state),controller._totalQueuedBytes>0)return void(controller._closeRequested=!0);if(controller._pendingPullIntos.length>0){var firstPendingPullInto=controller._pendingPullIntos[0];if(firstPendingPullInto.bytesFilled>0){var e=new TypeError("Insufficient bytes to fill elements in the given buffer");throw ReadableByteStreamControllerError(controller,e),e}}ReadableStreamClose(stream)}function ReadableByteStreamControllerEnqueue(controller,chunk){var stream=controller._controlledReadableStream;assert(controller._closeRequested===!1),assert("readable"===stream._state);var buffer=chunk.buffer,byteOffset=chunk.byteOffset,byteLength=chunk.byteLength,transferredBuffer=SameRealmTransfer(buffer);if(ReadableStreamHasDefaultReader(stream)===!0)if(0===ReadableStreamGetNumReadRequests(stream))ReadableByteStreamControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength);else{assert(0===controller._queue.length);var transferredView=new Uint8Array(transferredBuffer,byteOffset,byteLength);ReadableStreamFulfillReadRequest(stream,transferredView,!1)}else ReadableStreamHasBYOBReader(stream)===!0?(ReadableByteStreamControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)):(assert(IsReadableStreamLocked(stream)===!1,"stream must not be locked"),ReadableByteStreamControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength))}function ReadableByteStreamControllerError(controller,e){var stream=controller._controlledReadableStream;assert("readable"===stream._state),ReadableByteStreamControllerClearPendingPullIntos(controller),controller._queue=[],ReadableStreamError(stream,e)}function ReadableByteStreamControllerGetDesiredSize(controller){return controller._strategyHWM-controller._totalQueuedBytes}function ReadableByteStreamControllerRespond(controller,bytesWritten){if(bytesWritten=Number(bytesWritten),IsFiniteNonNegativeNumber(bytesWritten)===!1)throw new RangeError("bytesWritten must be a finite");assert(controller._pendingPullIntos.length>0),ReadableByteStreamControllerRespondInternal(controller,bytesWritten)}function ReadableByteStreamControllerRespondWithNewView(controller,view){assert(controller._pendingPullIntos.length>0);var firstDescriptor=controller._pendingPullIntos[0];if(firstDescriptor.byteOffset+firstDescriptor.bytesFilled!==view.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(firstDescriptor.byteLength!==view.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");firstDescriptor.buffer=view.buffer,ReadableByteStreamControllerRespondInternal(controller,view.byteLength)}function streamBrandCheckException(name){return new TypeError("ReadableStream.prototype."+name+" can only be used on a ReadableStream")}function readerLockException(name){return new TypeError("Cannot "+name+" a stream using a released reader")}function defaultReaderBrandCheckException(name){return new TypeError("ReadableStreamDefaultReader.prototype."+name+" can only be used on a ReadableStreamDefaultReader")}function defaultReaderClosedPromiseInitialize(reader){reader._closedPromise=new Promise(function(resolve,reject){reader._closedPromise_resolve=resolve,reader._closedPromise_reject=reject})}function defaultReaderClosedPromiseInitializeAsRejected(reader,reason){reader._closedPromise=Promise.reject(reason),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0}function defaultReaderClosedPromiseInitializeAsResolved(reader){reader._closedPromise=Promise.resolve(void 0),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0}function defaultReaderClosedPromiseReject(reader,reason){assert(void 0!==reader._closedPromise_resolve),assert(void 0!==reader._closedPromise_reject),reader._closedPromise_reject(reason),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0}function defaultReaderClosedPromiseResetToRejected(reader,reason){assert(void 0===reader._closedPromise_resolve),assert(void 0===reader._closedPromise_reject),reader._closedPromise=Promise.reject(reason)}function defaultReaderClosedPromiseResolve(reader){assert(void 0!==reader._closedPromise_resolve),assert(void 0!==reader._closedPromise_reject),reader._closedPromise_resolve(void 0),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0}function byobReaderBrandCheckException(name){return new TypeError("ReadableStreamBYOBReader.prototype."+name+" can only be used on a ReadableStreamBYOBReader")}function defaultControllerBrandCheckException(name){return new TypeError("ReadableStreamDefaultController.prototype."+name+" can only be used on a ReadableStreamDefaultController")}function byobRequestBrandCheckException(name){return new TypeError("ReadableStreamBYOBRequest.prototype."+name+" can only be used on a ReadableStreamBYOBRequest")}function byteStreamControllerBrandCheckException(name){return new TypeError("ReadableByteStreamController.prototype."+name+" can only be used on a ReadableByteStreamController")}var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),assert=require("assert"),_require=require("./helpers.js"),ArrayBufferCopy=_require.ArrayBufferCopy,CreateIterResultObject=_require.CreateIterResultObject,IsFiniteNonNegativeNumber=_require.IsFiniteNonNegativeNumber,InvokeOrNoop=_require.InvokeOrNoop,PromiseInvokeOrNoop=_require.PromiseInvokeOrNoop,SameRealmTransfer=_require.SameRealmTransfer,ValidateAndNormalizeQueuingStrategy=_require.ValidateAndNormalizeQueuingStrategy,ValidateAndNormalizeHighWaterMark=_require.ValidateAndNormalizeHighWaterMark,_require2=require("./helpers.js"),createArrayFromList=_require2.createArrayFromList,createDataProperty=_require2.createDataProperty,typeIsObject=_require2.typeIsObject,_require3=require("./utils.js"),rethrowAssertionErrorRejection=_require3.rethrowAssertionErrorRejection,_require4=require("./queue-with-sizes.js"),DequeueValue=_require4.DequeueValue,EnqueueValueWithSize=_require4.EnqueueValueWithSize,GetTotalQueueSize=_require4.GetTotalQueueSize,InternalCancel=Symbol("[[Cancel]]"),InternalPull=Symbol("[[Pull]]"),ReadableStream=function(){function ReadableStream(){var underlyingSource=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],_ref=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],size=_ref.size,highWaterMark=_ref.highWaterMark;_classCallCheck(this,ReadableStream),this._state="readable",this._reader=void 0,this._storedError=void 0,this._disturbed=!1,this._readableStreamController=void 0;var type=underlyingSource.type,typeString=String(type);if("bytes"===typeString)void 0===highWaterMark&&(highWaterMark=0),this._readableStreamController=new ReadableByteStreamController(this,underlyingSource,highWaterMark);else{if(void 0!==type)throw new RangeError("Invalid type is specified");void 0===highWaterMark&&(highWaterMark=1),this._readableStreamController=new ReadableStreamDefaultController(this,underlyingSource,size,highWaterMark)}}return _createClass(ReadableStream,[{key:"cancel",value:function(reason){return IsReadableStream(this)===!1?Promise.reject(streamBrandCheckException("cancel")):IsReadableStreamLocked(this)===!0?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):ReadableStreamCancel(this,reason)}},{key:"getReader",value:function(){var _ref2=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],mode=_ref2.mode;if(IsReadableStream(this)===!1)throw streamBrandCheckException("getReader");if("byob"===mode){if(IsReadableByteStreamController(this._readableStreamController)===!1)throw new TypeError("Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source");return AcquireReadableStreamBYOBReader(this)}if(void 0===mode)return AcquireReadableStreamDefaultReader(this);throw new RangeError("Invalid mode is specified")}},{key:"pipeThrough",value:function(_ref3,options){var writable=_ref3.writable,readable=_ref3.readable;return this.pipeTo(writable,options),readable}},{key:"pipeTo",value:function(dest){function releaseReader(){_reader.releaseLock(),_reader=void 0}function releaseWriter(){_writer.releaseLock(),_writer=void 0}function pipeDone(){assert(void 0===_reader),assert(void 0===_writer),_state="done",_lastRead=void 0,_lastWrite=void 0,_allWrites=void 0}function finishWithFulfillment(){_resolvePipeToPromise(void 0),_resolvePipeToPromise=void 0,_rejectPipeToPromise=void 0,pipeDone()}function finishWithRejection(reason){_rejectPipeToPromise(reason),_resolvePipeToPromise=void 0,_rejectPipeToPromise=void 0,pipeDone()}function abortWriterCancelReader(reason,skipAbort,skipCancel){var promises=[];return skipAbort===!1?(_writer.abort(reason),releaseWriter()):void 0===_lastWrite?releaseWriter():promises.push(_lastWrite.then(function(){releaseWriter()},function(){releaseWriter()})),skipCancel===!1?(_reader.cancel(reason),releaseReader()):void 0===_lastRead?releaseReader():promises.push(_lastRead.then(function(){releaseReader()},function(){releaseReader()})),promises.length>0?(Promise.all(promises).then(function(){finishWithRejection(reason)}),void(_state="waitingForLastReadAndOrLastWrite")):void finishWithRejection(reason)}function handleWriteRejection(reason){"piping"===_state&&abortWriterCancelReader(reason,preventAbort,preventCancel)}function handleReadValue(value){_lastWrite=_writer.write(value),_lastWrite["catch"](handleWriteRejection),_allWrites=Promise.all([_allWrites,_lastWrite]),doPipe()}function handleReadDone(){return releaseReader(),preventClose===!1?(_writer.close().then(function(){return _allWrites},function(reason){releaseWriter(),finishWithRejection(reason)}).then(function(){releaseWriter(),finishWithFulfillment()}),void(_state="closingDest")):void 0===_lastWrite?(releaseWriter(),void finishWithFulfillment()):(_lastWrite.then(function(){releaseWriter(),finishWithFulfillment()},function(reason){releaseWriter(),finishWithRejection(reason)}),void(_state="waitingLastWriteOnReadableClosed"))}function doPipe(){_lastRead=_reader.read(),Promise.all([_lastRead,_writer.ready]).then(function(_ref5){var _ref6=_slicedToArray(_ref5,1),_ref6$=_ref6[0],value=_ref6$.value,done=_ref6$.done;"piping"===_state&&(Boolean(done)===!1?handleReadValue(value):handleReadDone())},function(){})["catch"](rethrowAssertionErrorRejection)}function handleReaderClosedRejection(reason){"piping"===_state&&(_lastRead=void 0,abortWriterCancelReader(reason,preventAbort,!0))}function handleUnexpectedWriterCloseAndError(reason){"piping"===_state&&(_lastWrite=void 0,abortWriterCancelReader(reason,!0,preventCancel))}function handleWriterClosedFulfillment(){handleUnexpectedWriterCloseAndError(new TypeError("dest closed unexpectedly"))}function handleWriterClosedRejection(reason){handleUnexpectedWriterCloseAndError(reason)}var _ref4=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],preventClose=_ref4.preventClose,preventAbort=_ref4.preventAbort,preventCancel=_ref4.preventCancel;preventClose=Boolean(preventClose),preventAbort=Boolean(preventAbort),preventCancel=Boolean(preventCancel);var source=this,_resolvePipeToPromise=void 0,_rejectPipeToPromise=void 0,_reader=void 0,_writer=void 0,_state="piping",_lastRead=void 0,_lastWrite=void 0,_allWrites=void 0;return new Promise(function(resolve,reject){_resolvePipeToPromise=resolve,_rejectPipeToPromise=reject,_reader=source.getReader(),_writer=dest.getWriter(),_reader.closed["catch"](handleReaderClosedRejection),_writer.closed.then(handleWriterClosedFulfillment,handleWriterClosedRejection),doPipe()})}},{key:"tee",value:function(){if(IsReadableStream(this)===!1)throw streamBrandCheckException("tee");var branches=ReadableStreamTee(this,!1);return createArrayFromList(branches)}},{key:"locked",get:function(){if(IsReadableStream(this)===!1)throw streamBrandCheckException("locked");return IsReadableStreamLocked(this)}}]),ReadableStream}();exports.ReadableStream=ReadableStream,exports.IsReadableStreamDisturbed=IsReadableStreamDisturbed;var ReadableStreamDefaultReader=function(){function ReadableStreamDefaultReader(stream){if(_classCallCheck(this,ReadableStreamDefaultReader),IsReadableStream(stream)===!1)throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(IsReadableStreamLocked(stream)===!0)throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,stream),this._readRequests=[]}return _createClass(ReadableStreamDefaultReader,[{key:"cancel",value:function(reason){return IsReadableStreamDefaultReader(this)===!1?Promise.reject(defaultReaderBrandCheckException("cancel")):void 0===this._ownerReadableStream?Promise.reject(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,reason)}},{key:"read",value:function(){return IsReadableStreamDefaultReader(this)===!1?Promise.reject(defaultReaderBrandCheckException("read")):void 0===this._ownerReadableStream?Promise.reject(readerLockException("read from")):ReadableStreamDefaultReaderRead(this)}},{key:"releaseLock",value:function(){if(IsReadableStreamDefaultReader(this)===!1)throw defaultReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}},{key:"closed",get:function(){return IsReadableStreamDefaultReader(this)===!1?Promise.reject(defaultReaderBrandCheckException("closed")):this._closedPromise}}]),ReadableStreamDefaultReader}(),ReadableStreamBYOBReader=function(){function ReadableStreamBYOBReader(stream){if(_classCallCheck(this,ReadableStreamBYOBReader),!IsReadableStream(stream))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(IsReadableStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,stream),this._readIntoRequests=[]}return _createClass(ReadableStreamBYOBReader,[{key:"cancel",value:function(reason){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?Promise.reject(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,reason):Promise.reject(byobReaderBrandCheckException("cancel"))}},{key:"read",value:function(view){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?Promise.reject(readerLockException("read from")):ArrayBuffer.isView(view)?0===view.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):ReadableStreamBYOBReaderRead(this,view):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(byobReaderBrandCheckException("read"))}},{key:"releaseLock",value:function(){if(!IsReadableStreamBYOBReader(this))throw byobReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}},{key:"closed",get:function(){return IsReadableStreamBYOBReader(this)?this._closedPromise:Promise.reject(byobReaderBrandCheckException("closed"))}}]),ReadableStreamBYOBReader}(),ReadableStreamDefaultController=function(){function ReadableStreamDefaultController(stream,underlyingSource,size,highWaterMark){if(_classCallCheck(this,ReadableStreamDefaultController),IsReadableStream(stream)===!1)throw new TypeError("ReadableStreamDefaultController can only be constructed with a ReadableStream instance");if(void 0!==stream._readableStreamController)throw new TypeError("ReadableStreamDefaultController instances can only be created by the ReadableStream constructor");this._controlledReadableStream=stream,this._underlyingSource=underlyingSource,this._queue=[],this._started=!1,this._closeRequested=!1,this._pullAgain=!1,this._pulling=!1;var normalizedStrategy=ValidateAndNormalizeQueuingStrategy(size,highWaterMark);this._strategySize=normalizedStrategy.size,this._strategyHWM=normalizedStrategy.highWaterMark;var controller=this,startResult=InvokeOrNoop(underlyingSource,"start",[this]);Promise.resolve(startResult).then(function(){controller._started=!0,
ReadableStreamDefaultControllerCallPullIfNeeded(controller)},function(r){ReadableStreamDefaultControllerErrorIfNeeded(controller,r)})["catch"](rethrowAssertionErrorRejection)}return _createClass(ReadableStreamDefaultController,[{key:"close",value:function(){if(IsReadableStreamDefaultController(this)===!1)throw defaultControllerBrandCheckException("close");if(this._closeRequested===!0)throw new TypeError("The stream has already been closed; do not close it again!");var state=this._controlledReadableStream._state;if("readable"!==state)throw new TypeError("The stream (in "+state+" state) is not in the readable state and cannot be closed");ReadableStreamDefaultControllerClose(this)}},{key:"enqueue",value:function(chunk){if(IsReadableStreamDefaultController(this)===!1)throw defaultControllerBrandCheckException("enqueue");if(this._closeRequested===!0)throw new TypeError("stream is closed or draining");var state=this._controlledReadableStream._state;if("readable"!==state)throw new TypeError("The stream (in "+state+" state) is not in the readable state and cannot be enqueued to");return ReadableStreamDefaultControllerEnqueue(this,chunk)}},{key:"error",value:function(e){if(IsReadableStreamDefaultController(this)===!1)throw defaultControllerBrandCheckException("error");var stream=this._controlledReadableStream;if("readable"!==stream._state)throw new TypeError("The stream is "+stream._state+" and so cannot be errored");ReadableStreamDefaultControllerError(this,e)}},{key:InternalCancel,value:function(reason){return this._queue=[],PromiseInvokeOrNoop(this._underlyingSource,"cancel",[reason])}},{key:InternalPull,value:function(){var stream=this._controlledReadableStream;if(this._queue.length>0){var chunk=DequeueValue(this._queue);return this._closeRequested===!0&&0===this._queue.length?ReadableStreamClose(stream):ReadableStreamDefaultControllerCallPullIfNeeded(this),Promise.resolve(CreateIterResultObject(chunk,!1))}var pendingPromise=ReadableStreamAddReadRequest(stream);return ReadableStreamDefaultControllerCallPullIfNeeded(this),pendingPromise}},{key:"desiredSize",get:function(){if(IsReadableStreamDefaultController(this)===!1)throw defaultControllerBrandCheckException("desiredSize");return ReadableStreamDefaultControllerGetDesiredSize(this)}}]),ReadableStreamDefaultController}(),ReadableStreamBYOBRequest=function(){function ReadableStreamBYOBRequest(controller,view){_classCallCheck(this,ReadableStreamBYOBRequest),this._associatedReadableByteStreamController=controller,this._view=view}return _createClass(ReadableStreamBYOBRequest,[{key:"respond",value:function(bytesWritten){if(IsReadableStreamBYOBRequest(this)===!1)throw byobRequestBrandCheckException("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,bytesWritten)}},{key:"respondWithNewView",value:function(view){if(IsReadableStreamBYOBRequest(this)===!1)throw byobRequestBrandCheckException("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(view))throw new TypeError("You can only respond with array buffer views");ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,view)}},{key:"view",get:function(){return this._view}}]),ReadableStreamBYOBRequest}(),ReadableByteStreamController=function(){function ReadableByteStreamController(stream,underlyingByteSource,highWaterMark){if(_classCallCheck(this,ReadableByteStreamController),IsReadableStream(stream)===!1)throw new TypeError("ReadableByteStreamController can only be constructed with a ReadableStream instance given a byte source");if(void 0!==stream._readableStreamController)throw new TypeError("ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte source");this._controlledReadableStream=stream,this._underlyingByteSource=underlyingByteSource,this._pullAgain=!1,this._pulling=!1,ReadableByteStreamControllerClearPendingPullIntos(this),this._queue=[],this._totalQueuedBytes=0,this._closeRequested=!1,this._started=!1,this._strategyHWM=ValidateAndNormalizeHighWaterMark(highWaterMark);var autoAllocateChunkSize=underlyingByteSource.autoAllocateChunkSize;if(void 0!==autoAllocateChunkSize&&(Number.isInteger(autoAllocateChunkSize)===!1||0>autoAllocateChunkSize))throw new RangeError("autoAllocateChunkSize must be a non negative integer");this._autoAllocateChunkSize=autoAllocateChunkSize,this._pendingPullIntos=[];var controller=this,startResult=InvokeOrNoop(underlyingByteSource,"start",[this]);Promise.resolve(startResult).then(function(){controller._started=!0,assert(controller._pulling===!1),assert(controller._pullAgain===!1),ReadableByteStreamControllerCallPullIfNeeded(controller)},function(r){"readable"===stream._state&&ReadableByteStreamControllerError(controller,r)})["catch"](rethrowAssertionErrorRejection)}return _createClass(ReadableByteStreamController,[{key:"close",value:function(){if(IsReadableByteStreamController(this)===!1)throw byteStreamControllerBrandCheckException("close");if(this._closeRequested===!0)throw new TypeError("The stream has already been closed; do not close it again!");var state=this._controlledReadableStream._state;if("readable"!==state)throw new TypeError("The stream (in "+state+" state) is not in the readable state and cannot be closed");ReadableByteStreamControllerClose(this)}},{key:"enqueue",value:function(chunk){if(IsReadableByteStreamController(this)===!1)throw byteStreamControllerBrandCheckException("enqueue");if(this._closeRequested===!0)throw new TypeError("stream is closed or draining");var state=this._controlledReadableStream._state;if("readable"!==state)throw new TypeError("The stream (in "+state+" state) is not in the readable state and cannot be enqueued to");if(!ArrayBuffer.isView(chunk))throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");ReadableByteStreamControllerEnqueue(this,chunk)}},{key:"error",value:function(e){if(IsReadableByteStreamController(this)===!1)throw byteStreamControllerBrandCheckException("error");var stream=this._controlledReadableStream;if("readable"!==stream._state)throw new TypeError("The stream is "+stream._state+" and so cannot be errored");ReadableByteStreamControllerError(this,e)}},{key:InternalCancel,value:function(reason){if(this._pendingPullIntos.length>0){var firstDescriptor=this._pendingPullIntos[0];firstDescriptor.bytesFilled=0}return this._queue=[],this._totalQueuedBytes=0,PromiseInvokeOrNoop(this._underlyingByteSource,"cancel",[reason])}},{key:InternalPull,value:function(){var stream=this._controlledReadableStream;if(0===ReadableStreamGetNumReadRequests(stream)){if(this._totalQueuedBytes>0){var entry=this._queue.shift();this._totalQueuedBytes-=entry.byteLength,ReadableByteStreamControllerHandleQueueDrain(this);var view=void 0;try{view=new Uint8Array(entry.buffer,entry.byteOffset,entry.byteLength)}catch(viewE){return Promise.reject(viewE)}return Promise.resolve(CreateIterResultObject(view,!1))}var autoAllocateChunkSize=this._autoAllocateChunkSize;if(void 0!==autoAllocateChunkSize){var buffer=void 0;try{buffer=new ArrayBuffer(autoAllocateChunkSize)}catch(bufferE){return Promise.reject(bufferE)}var pullIntoDescriptor={buffer:buffer,byteOffset:0,byteLength:autoAllocateChunkSize,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(pullIntoDescriptor)}}else assert(void 0===this._autoAllocateChunkSize);var promise=ReadableStreamAddReadRequest(stream);return ReadableByteStreamControllerCallPullIfNeeded(this),promise}},{key:"byobRequest",get:function(){if(IsReadableByteStreamController(this)===!1)throw byteStreamControllerBrandCheckException("byobRequest");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){var firstDescriptor=this._pendingPullIntos[0],view=new Uint8Array(firstDescriptor.buffer,firstDescriptor.byteOffset+firstDescriptor.bytesFilled,firstDescriptor.byteLength-firstDescriptor.bytesFilled);this._byobRequest=new ReadableStreamBYOBRequest(this,view)}return this._byobRequest}},{key:"desiredSize",get:function(){if(IsReadableByteStreamController(this)===!1)throw byteStreamControllerBrandCheckException("desiredSize");return ReadableByteStreamControllerGetDesiredSize(this)}}]),ReadableByteStreamController}()},{"./helpers.js":9,"./queue-with-sizes.js":10,"./utils.js":13,assert:2}],12:[function(require,module,exports){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function TransformStreamCloseReadable(transformStream){if(transformStream._errored===!0)throw new TypeError("TransformStream is already errored");if(transformStream._readableClosed===!0)throw new TypeError("Readable side is already closed");try{transformStream._readableController.close()}catch(e){assert(!1)}transformStream._readableClosed=!0}function TransformStreamEnqueueToReadable(transformStream,chunk){if(transformStream._errroed===!0)throw new TypeError("TransformStream is already errored");if(transformStream._readableClosed===!0)throw new TypeError("Readable side is already closed");var controller=transformStream._readableController;transformStream._readableBackpressure=!0;try{controller.enqueue(chunk)}catch(e){if(transformStream._error===!1){var reason=new TypeError("Failed to enqueue to readable side");TransformStreamErrorInternal(transformStream,reason)}throw transformStream._error}var backpressure=void 0;try{backpressure=controller.desiredSize<=0}catch(e){if(transformStream._error===!1){var reason=new TypeError("Failed to calculate backpressure of readable side");TransformStreamError(transformStream,reason)}throw transformStream._error}backpressure&&(transformStream._readableBackpressure=!1)}function TransformStreamError(transformStream,e){if(transformStream._errored===!0)throw new TypeError("TransformStream is already errored");TransformStreamErrorInternal(transformStream,e)}function TransformStreamChunkDone(transformStream){if(transformStream._errroed===!0)throw new TypeError("TransformStream is already errored");if(transformStream._transforming===!1)throw new TypeError("No active transform is running");assert(void 0!==transformStream._resolveWrite),transformStream._transforming=!1,transformStream._resolveWrite(void 0),transformStream._resolveWrite=void 0,TransformStreamTransformIfNeeded(transformStream)}function TransformStreamErrorInternal(transformStream,e){transformStream._errored=!0,transformStream._writableDone===!1&&transformStream._writableController.error(e),transformStream._readableClosed===!1&&transformStream._readableController.error(e),transformStream._chunk=void 0,void 0!==transformStream._resolveWriter&&transformStream._resolveWriter(void 0)}function TransformStreamTransformIfNeeded(transformStream){if(transformStream._chunkPending!==!1&&(assert(void 0!==transformStream._resolveWrite),transformStream._transforming!==!0&&transformStream._readableBackpressure!==!0)){transformStream._transforming=!0;var chunk=transformStream._chunk;transformStream._chunkPending=!1,transformStream._chunk=void 0;try{void 0!==transformStream._transformer.transform&&transformStream._transformer.transform(chunk,TransformStreamChunkDone.bind(void 0,transformStream),transformStream._enqueueFunction,transformStream._closeFunction,transformStream._errorFunction)}catch(e){transformStream._errored===!1&&TransformStreamErrorInternal(transformStream,e)}}}function TransformStreamStart(transformStream){void 0!==transformStream._transformer.start&&transformStream._transformer.start(transformStream._enqueueFunction,transformStream._closeFunction,transformStream._errorFunction)}var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),assert=require("assert"),_require=require("./readable-stream.js"),ReadableStream=_require.ReadableStream,_require2=require("./writable-stream.js"),WritableStream=_require2.WritableStream,TransformStreamSink=function(){function TransformStreamSink(transformStream){_classCallCheck(this,TransformStreamSink),this._transformStream=transformStream}return _createClass(TransformStreamSink,[{key:"start",value:function(c){var transformStream=this._transformStream;transformStream._writableController=c,void 0!==transformStream._readableController&&TransformStreamStart(transformStream)}},{key:"write",value:function(chunk){var transformStream=this._transformStream;assert(transformStream._errored===!1),assert(transformStream._chunkPending===!1),assert(void 0===transformStream._chunk),assert(void 0===transformStream._resolveWrite),transformStream._chunkPending=!0,transformStream._chunk=chunk;var promise=new Promise(function(resolve){transformStream._resolveWrite=resolve});return TransformStreamTransformIfNeeded(transformStream),promise}},{key:"abort",value:function(){var transformStream=this._transformStream;transformStream._writableDone=!0,TransformStreamErrorInternal(transformStream,new TypeError("Writable side aborted"))}},{key:"close",value:function(){var transformStream=this._transformStream;if(assert(transformStream._chunkPending===!1),assert(void 0===transformStream._chunk),assert(void 0===transformStream._resolveWrite),assert(transformStream._transforming===!1),transformStream._writableDone=!0,void 0===transformStream._transformer.flush)TransformStreamCloseReadable(transformStream);else try{transformStream._transformer.flush(transformStream._enqueueFunction,transformStream._closeFunction,transformStream._errorFunction)}catch(e){if(transformStream._errored===!1)throw TransformStreamErrorInternal(transformStream,e),e}}}]),TransformStreamSink}(),TransformStreamSource=function(){function TransformStreamSource(transformStream){_classCallCheck(this,TransformStreamSource),this._transformStream=transformStream}return _createClass(TransformStreamSource,[{key:"start",value:function(c){var transformStream=this._transformStream;transformStream._readableController=c,void 0!==transformStream._writableController&&TransformStreamStart(transformStream)}},{key:"pull",value:function(){this._transformStream._readableBackpressure=!1,TransformStreamTransformIfNeeded(this._transformStream)}},{key:"cancel",value:function(){var transformStream=this._transformStream;transformStream._readableClosed=!0,TransformStreamErrorInternal(transformStream,new TypeError("Readable side canceled"))}}]),TransformStreamSource}();module.exports=function TransformStream(transformer){if(_classCallCheck(this,TransformStream),void 0!==transformer.start&&"function"!=typeof transformer.start)throw new TypeError("start must be a function or undefined");if("function"!=typeof transformer.transform)throw new TypeError("transform must be a function");if(void 0!==transformer.flush&&"function"!=typeof transformer.flush)throw new TypeError("flush must be a function or undefined");this._transformer=transformer,this._transforming=!1,this._errored=!1,this._writableController=void 0,this._readableController=void 0,this._writableDone=!1,this._readableClosed=!1,this._resolveWrite=void 0,this._chunkPending=!1,this._chunk=void 0,this._enqueueFunction=TransformStreamEnqueueToReadable.bind(void 0,this),this._closeFunction=TransformStreamCloseReadable.bind(void 0,this),this._errorFunction=TransformStreamError.bind(void 0,this);var sink=new TransformStreamSink(this);try{this.writable=new WritableStream(sink,transformer.writableStrategy)}catch(e){if(this._errored===!1)throw TransformStreamError(this,e),e;return}var source=new TransformStreamSource(this);try{this.readable=new ReadableStream(source,transformer.readableStrategy)}catch(e){if(this.writable=void 0,this._errored===!1)throw TransformStreamError(this,e),e}}},{"./readable-stream.js":11,"./writable-stream.js":14,assert:2}],13:[function(require,module,exports){"use strict";var assert=require("assert");exports.rethrowAssertionErrorRejection=function(e){e&&e.constructor===assert.AssertionError&&setTimeout(function(){throw e},0)}},{assert:2}],14:[function(require,module,exports){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function AcquireWritableStreamDefaultWriter(stream){return new WritableStreamDefaultWriter(stream)}function IsWritableStream(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_writableStreamController"):!1}function IsWritableStreamLocked(stream){return assert(IsWritableStream(stream)===!0,"IsWritableStreamLocked should only be used on known writable streams"),void 0!==stream._writer}function WritableStreamAbort(stream,reason){var state=stream._state;if("closed"===state)return Promise.resolve(void 0);if("errored"===state)return Promise.reject(stream._storedError);assert("writable"===state||"closing"===state);var error=new TypeError("Aborted");return WritableStreamError(stream,error),WritableStreamDefaultControllerAbort(stream._writableStreamController,reason)}function WritableStreamAddWriteRequest(stream){assert(IsWritableStreamLocked(stream)===!0),assert("writable"===stream._state);var promise=new Promise(function(resolve,reject){var writeRequest={_resolve:resolve,_reject:reject};stream._writeRequests.push(writeRequest)});return promise}function WritableStreamError(stream,e){var state=stream._state;assert("writable"===state||"closing"===state);var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _step,_iterator=stream._writeRequests[Symbol.iterator]();!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var writeRequest=_step.value;writeRequest._reject(e)}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator["return"]&&_iterator["return"]()}finally{if(_didIteratorError)throw _iteratorError}}stream._writeRequests=[];var writer=stream._writer;void 0!==writer&&(defaultWriterClosedPromiseReject(writer,e),"writable"===state&&WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController)===!0&&defaultWriterReadyPromiseResolve(writer)),stream._state="errored",stream._storedError=e}function WritableStreamFinishClose(stream){assert("closing"===stream._state),assert(void 0!==stream._writer),stream._state="closed",defaultWriterClosedPromiseResolve(stream._writer)}function WritableStreamFulfillWriteRequest(stream){assert(stream._writeRequests.length>0);var writeRequest=stream._writeRequests.shift();writeRequest._resolve(void 0)}function WritableStreamUpdateBackpressure(stream,backpressure){assert("writable"===stream._state);var writer=stream._writer;void 0!==writer&&(backpressure===!0?defaultWriterReadyPromiseReset(writer):(assert(backpressure===!1),defaultWriterReadyPromiseResolve(writer)))}function IsWritableStreamDefaultWriter(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_ownerWritableStream"):!1}function WritableStreamDefaultWriterAbort(writer,reason){var stream=writer._ownerWritableStream;return assert(void 0!==stream),WritableStreamAbort(stream,reason)}function WritableStreamDefaultWriterClose(writer){var stream=writer._ownerWritableStream;assert(void 0!==stream);var state=stream._state;if("closed"===state||"errored"===state)return Promise.reject(new TypeError("The stream (in "+state+" state) is not in the writable state and cannot be closed"));assert("writable"===state);var promise=WritableStreamAddWriteRequest(stream);return WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController)===!0&&defaultWriterReadyPromiseResolve(writer),stream._state="closing",WritableStreamDefaultControllerClose(stream._writableStreamController),promise}function WritableStreamDefaultWriterGetDesiredSize(writer){var stream=writer._ownerWritableStream,state=stream._state;return"errored"===state?null:"closed"===state?0:WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController)}function WritableStreamDefaultWriterWrite(writer,chunk){var stream=writer._ownerWritableStream;assert(void 0!==stream);var state=stream._state;if("closed"===state||"errored"===state)return Promise.reject(new TypeError("The stream (in "+state+" state) is not in the writable state and cannot be written to"));assert("writable"===state);var promise=WritableStreamAddWriteRequest(stream);return WritableStreamDefaultControllerWrite(stream._writableStreamController,chunk),promise}function WritableStreamDefaultControllerAbort(controller,reason){controller._queue=[];var sinkAbortPromise=PromiseInvokeOrFallbackOrNoop(controller._underlyingSink,"abort",[reason],"close",[]);return sinkAbortPromise.then(function(){})}function WritableStreamDefaultControllerClose(controller){EnqueueValueWithSize(controller._queue,"close",0),WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)}function WritableStreamDefaultControllerGetDesiredSize(controller){var queueSize=GetTotalQueueSize(controller._queue);return controller._strategyHWM-queueSize}function WritableStreamDefaultControllerWrite(controller,chunk){var stream=controller._controlledWritableStream;assert("writable"===stream._state);var chunkSize=1;if(void 0!==controller._strategySize)try{chunkSize=controller._strategySize(chunk)}catch(chunkSizeE){return WritableStreamDefaultControllerErrorIfNeeded(controller,chunkSizeE),Promise.reject(chunkSizeE)}var writeRecord={chunk:chunk},lastBackpressure=WritableStreamDefaultControllerGetBackpressure(controller);try{EnqueueValueWithSize(controller._queue,writeRecord,chunkSize)}catch(enqueueE){return WritableStreamDefaultControllerErrorIfNeeded(controller,enqueueE),Promise.reject(enqueueE)}if("writable"===stream._state){var backpressure=WritableStreamDefaultControllerGetBackpressure(controller);lastBackpressure!==backpressure&&WritableStreamUpdateBackpressure(stream,backpressure)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)}function IsWritableStreamDefaultController(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_underlyingSink"):!1}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller){if("closed"!==controller._controlledWritableStream._state&&"errored"!==controller._controlledWritableStream._state&&controller._started!==!1&&controller._writing!==!0&&0!==controller._queue.length){var writeRecord=PeekQueueValue(controller._queue);"close"===writeRecord?WritableStreamDefaultControllerProcessClose(controller):WritableStreamDefaultControllerProcessWrite(controller,writeRecord.chunk)}}function WritableStreamDefaultControllerErrorIfNeeded(controller,e){"writable"!==controller._controlledWritableStream._state&&"closing"!==controller._controlledWritableStream._state||WritableStreamDefaultControllerError(controller,e)}function WritableStreamDefaultControllerProcessClose(controller){var stream=controller._controlledWritableStream;assert("closing"===stream._state,"can't process final write record unless already closed"),DequeueValue(controller._queue),assert(0===controller._queue.length,"queue must be empty once the final write record is dequeued");var sinkClosePromise=PromiseInvokeOrNoop(controller._underlyingSink,"close");sinkClosePromise.then(function(){"closing"===stream._state&&(WritableStreamFulfillWriteRequest(stream),WritableStreamFinishClose(stream))},function(r){WritableStreamDefaultControllerErrorIfNeeded(controller,r)})["catch"](rethrowAssertionErrorRejection)}function WritableStreamDefaultControllerProcessWrite(controller,chunk){controller._writing=!0;var sinkWritePromise=PromiseInvokeOrNoop(controller._underlyingSink,"write",[chunk]);sinkWritePromise.then(function(){var stream=controller._controlledWritableStream,state=stream._state;if("errored"!==state&&"closed"!==state){controller._writing=!1,WritableStreamFulfillWriteRequest(stream);var lastBackpressure=WritableStreamDefaultControllerGetBackpressure(controller);if(DequeueValue(controller._queue),"closing"!==state){var backpressure=WritableStreamDefaultControllerGetBackpressure(controller);lastBackpressure!==backpressure&&WritableStreamUpdateBackpressure(controller._controlledWritableStream,backpressure)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)}},function(r){WritableStreamDefaultControllerErrorIfNeeded(controller,r)})["catch"](rethrowAssertionErrorRejection)}function WritableStreamDefaultControllerGetBackpressure(controller){var desiredSize=WritableStreamDefaultControllerGetDesiredSize(controller);return 0>=desiredSize}function WritableStreamDefaultControllerError(controller,e){var stream=controller._controlledWritableStream;assert("writable"===stream._state||"closing"===stream._state),WritableStreamError(stream,e),controller._queue=[]}function streamBrandCheckException(name){return new TypeError("WritableStream.prototype."+name+" can only be used on a WritableStream")}function defaultWriterBrandCheckException(name){return new TypeError("WritableStreamDefaultWriter.prototype."+name+" can only be used on a WritableStreamDefaultWriter")}function defaultWriterLockException(name){return new TypeError("Cannot "+name+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(writer){writer._closedPromise=new Promise(function(resolve,reject){writer._closedPromise_resolve=resolve,writer._closedPromise_reject=reject})}function defaultWriterClosedPromiseInitializeAsRejected(writer,reason){writer._closedPromise=Promise.reject(reason),writer._closedPromise_resolve=void 0,writer._closedPromise_reject=void 0}function defaultWriterClosedPromiseInitializeAsResolved(writer){writer._closedPromise=Promise.resolve(void 0),writer._closedPromise_resolve=void 0,writer._closedPromise_reject=void 0}function defaultWriterClosedPromiseReject(writer,reason){assert(void 0!==writer._closedPromise_resolve),assert(void 0!==writer._closedPromise_reject),writer._closedPromise_reject(reason),writer._closedPromise_resolve=void 0,writer._closedPromise_reject=void 0}function defaultWriterClosedPromiseResetToRejected(writer,reason){assert(void 0===writer._closedPromise_resolve),assert(void 0===writer._closedPromise_reject),writer._closedPromise=Promise.reject(reason)}function defaultWriterClosedPromiseResolve(writer){assert(void 0!==writer._closedPromise_resolve),assert(void 0!==writer._closedPromise_reject),writer._closedPromise_resolve(void 0),writer._closedPromise_resolve=void 0,writer._closedPromise_reject=void 0}function defaultWriterReadyPromiseInitialize(writer){writer._readyPromise=new Promise(function(resolve,reject){writer._readyPromise_resolve=resolve,writer._readyPromise_reject=reject})}function defaultWriterReadyPromiseInitializeAsResolved(writer){writer._readyPromise=Promise.resolve(void 0),writer._readyPromise_resolve=void 0,writer._readyPromise_reject=void 0}function defaultWriterReadyPromiseReject(writer,reason){assert(void 0!==writer._readyPromise_resolve),assert(void 0!==writer._readyPromise_reject),writer._readyPromise_reject(reason),writer._readyPromise_resolve=void 0,writer._readyPromise_reject=void 0}function defaultWriterReadyPromiseReset(writer){assert(void 0===writer._readyPromise_resolve),assert(void 0===writer._readyPromise_reject),writer._readyPromise=new Promise(function(resolve,reject){writer._readyPromise_resolve=resolve,writer._readyPromise_reject=reject})}function defaultWriterReadyPromiseResetToRejected(writer,reason){assert(void 0===writer._readyPromise_resolve),assert(void 0===writer._readyPromise_reject),writer._readyPromise=Promise.reject(reason)}function defaultWriterReadyPromiseResolve(writer){assert(void 0!==writer._readyPromise_resolve),assert(void 0!==writer._readyPromise_reject),writer._readyPromise_resolve(void 0),writer._readyPromise_resolve=void 0,writer._readyPromise_reject=void 0}var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),assert=require("assert"),_require=require("./helpers.js"),InvokeOrNoop=_require.InvokeOrNoop,PromiseInvokeOrNoop=_require.PromiseInvokeOrNoop,PromiseInvokeOrFallbackOrNoop=_require.PromiseInvokeOrFallbackOrNoop,ValidateAndNormalizeQueuingStrategy=_require.ValidateAndNormalizeQueuingStrategy,typeIsObject=_require.typeIsObject,_require2=require("./utils.js"),rethrowAssertionErrorRejection=_require2.rethrowAssertionErrorRejection,_require3=require("./queue-with-sizes.js"),DequeueValue=_require3.DequeueValue,EnqueueValueWithSize=_require3.EnqueueValueWithSize,GetTotalQueueSize=_require3.GetTotalQueueSize,PeekQueueValue=_require3.PeekQueueValue,WritableStream=function(){function WritableStream(){var underlyingSink=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],_ref=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],size=_ref.size,_ref$highWaterMark=_ref.highWaterMark,highWaterMark=void 0===_ref$highWaterMark?1:_ref$highWaterMark;_classCallCheck(this,WritableStream),this._state="writable",this._storedError=void 0,this._writer=void 0,this._writableStreamController=void 0,this._writeRequests=[];var type=underlyingSink.type;if(void 0!==type)throw new RangeError("Invalid type is specified");this._writableStreamController=new WritableStreamDefaultController(this,underlyingSink,size,highWaterMark)}return _createClass(WritableStream,[{key:"abort",value:function(reason){return IsWritableStream(this)===!1?Promise.reject(streamBrandCheckException("abort")):IsWritableStreamLocked(this)===!0?Promise.reject(new TypeError("Cannot abort a stream that already has a writer")):WritableStreamAbort(this,reason)}},{key:"getWriter",value:function(){if(IsWritableStream(this)===!1)throw streamBrandCheckException("getWriter");return AcquireWritableStreamDefaultWriter(this)}},{key:"locked",get:function(){if(IsWritableStream(this)===!1)throw streamBrandCheckException("locked");return IsWritableStreamLocked(this)}}]),WritableStream}();exports.WritableStream=WritableStream;var WritableStreamDefaultWriter=function(){function WritableStreamDefaultWriter(stream){if(_classCallCheck(this,WritableStreamDefaultWriter),IsWritableStream(stream)===!1)throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");if(IsWritableStreamLocked(stream)===!0)throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=stream,stream._writer=this;var state=stream._state;"writable"===state||"closing"===state?defaultWriterClosedPromiseInitialize(this):"closed"===state?defaultWriterClosedPromiseInitializeAsResolved(this):(assert("errored"===state,"state must be errored"),defaultWriterClosedPromiseInitializeAsRejected(this,stream._storedError)),"writable"===state&&WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController)===!0?defaultWriterReadyPromiseInitialize(this):defaultWriterReadyPromiseInitializeAsResolved(this,void 0)}return _createClass(WritableStreamDefaultWriter,[{key:"abort",value:function(reason){return IsWritableStreamDefaultWriter(this)===!1?Promise.reject(defaultWriterBrandCheckException("abort")):void 0===this._ownerWritableStream?Promise.reject(defaultWriterLockException("abort")):WritableStreamDefaultWriterAbort(this,reason);
}},{key:"close",value:function(){if(IsWritableStreamDefaultWriter(this)===!1)return Promise.reject(defaultWriterBrandCheckException("close"));var stream=this._ownerWritableStream;return void 0===stream?Promise.reject(defaultWriterLockException("close")):"closing"===stream._state?Promise.reject(new TypeError("cannot close an already-closing stream")):WritableStreamDefaultWriterClose(this)}},{key:"releaseLock",value:function(){if(IsWritableStreamDefaultWriter(this)===!1)throw defaultWriterBrandCheckException("releaseLock");var stream=this._ownerWritableStream;if(void 0!==stream){assert(void 0!==stream._writer);var state=stream._state,releasedException=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");"writable"===state||"closing"===state?defaultWriterClosedPromiseReject(this,releasedException):defaultWriterClosedPromiseResetToRejected(this,releasedException),"writable"===state&&WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController)===!0?defaultWriterReadyPromiseReject(this,releasedException):defaultWriterReadyPromiseResetToRejected(this,releasedException),stream._writer=void 0,this._ownerWritableStream=void 0}}},{key:"write",value:function(chunk){if(IsWritableStreamDefaultWriter(this)===!1)return Promise.reject(defaultWriterBrandCheckException("write"));var stream=this._ownerWritableStream;return void 0===stream?Promise.reject(defaultWriterLockException("write to")):"closing"===stream._state?Promise.reject(new TypeError("Cannot write to an already-closed stream")):WritableStreamDefaultWriterWrite(this,chunk)}},{key:"closed",get:function(){return IsWritableStreamDefaultWriter(this)===!1?Promise.reject(defaultWriterBrandCheckException("closed")):this._closedPromise}},{key:"desiredSize",get:function(){if(IsWritableStreamDefaultWriter(this)===!1)throw defaultWriterBrandCheckException("desiredSize");if(void 0===this._ownerWritableStream)throw defaultWriterLockException("desiredSize");return WritableStreamDefaultWriterGetDesiredSize(this)}},{key:"ready",get:function(){return IsWritableStreamDefaultWriter(this)===!1?Promise.reject(defaultWriterBrandCheckException("ready")):this._readyPromise}}]),WritableStreamDefaultWriter}(),WritableStreamDefaultController=function(){function WritableStreamDefaultController(stream,underlyingSink,size,highWaterMark){if(_classCallCheck(this,WritableStreamDefaultController),IsWritableStream(stream)===!1)throw new TypeError("WritableStreamDefaultController can only be constructed with a WritableStream instance");if(void 0!==stream._writableStreamController)throw new TypeError("WritableStreamDefaultController instances can only be created by the WritableStream constructor");this._controlledWritableStream=stream,this._underlyingSink=underlyingSink,this._queue=[],this._started=!1,this._writing=!1;var normalizedStrategy=ValidateAndNormalizeQueuingStrategy(size,highWaterMark);this._strategySize=normalizedStrategy.size,this._strategyHWM=normalizedStrategy.highWaterMark;var backpressure=WritableStreamDefaultControllerGetBackpressure(this);backpressure===!0&&WritableStreamUpdateBackpressure(stream,backpressure);var controller=this,startResult=InvokeOrNoop(underlyingSink,"start",[this]);Promise.resolve(startResult).then(function(){controller._started=!0,WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller)},function(r){WritableStreamDefaultControllerErrorIfNeeded(controller,r)})["catch"](rethrowAssertionErrorRejection)}return _createClass(WritableStreamDefaultController,[{key:"error",value:function(e){if(IsWritableStreamDefaultController(this)===!1)throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");var state=this._controlledWritableStream._state;if("closed"===state||"errored"===state)throw new TypeError("The stream is "+state+" and so cannot be errored");WritableStreamDefaultControllerError(this,e)}}]),WritableStreamDefaultController}()},{"./helpers.js":9,"./queue-with-sizes.js":10,"./utils.js":13,assert:2}]},{},[1])(1)});